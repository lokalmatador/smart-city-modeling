/*
 * generated by Xtext 2.36.0
 */
package org.smartcitymodel.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.smartcitymodel.dsl.Actor;
import org.smartcitymodel.dsl.CompoundEntity;
import org.smartcitymodel.dsl.Condition;
import org.smartcitymodel.dsl.ConditionalStatement;
import org.smartcitymodel.dsl.Connection;
import org.smartcitymodel.dsl.Controller;
import org.smartcitymodel.dsl.DslPackage;
import org.smartcitymodel.dsl.Effect;
import org.smartcitymodel.dsl.Frequency;
import org.smartcitymodel.dsl.Location;
import org.smartcitymodel.dsl.Port;
import org.smartcitymodel.dsl.Property;
import org.smartcitymodel.dsl.Sensor;
import org.smartcitymodel.dsl.Service;
import org.smartcitymodel.dsl.SmartCityModel;
import org.smartcitymodel.services.DslGrammarAccess;

@SuppressWarnings("all")
public class DslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DslPackage.ACTION:
				sequence_Action(context, (org.smartcitymodel.dsl.Action) semanticObject); 
				return; 
			case DslPackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case DslPackage.COMPOUND_ENTITY:
				sequence_CompoundEntity(context, (CompoundEntity) semanticObject); 
				return; 
			case DslPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case DslPackage.CONDITIONAL_STATEMENT:
				sequence_ConditionalStatement(context, (ConditionalStatement) semanticObject); 
				return; 
			case DslPackage.CONNECTION:
				sequence_Connection(context, (Connection) semanticObject); 
				return; 
			case DslPackage.CONTROLLER:
				sequence_Controller(context, (Controller) semanticObject); 
				return; 
			case DslPackage.EFFECT:
				sequence_Effect(context, (Effect) semanticObject); 
				return; 
			case DslPackage.FREQUENCY:
				sequence_Frequency(context, (Frequency) semanticObject); 
				return; 
			case DslPackage.LOCATION:
				sequence_Location(context, (Location) semanticObject); 
				return; 
			case DslPackage.PORT:
				sequence_Port(context, (Port) semanticObject); 
				return; 
			case DslPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case DslPackage.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case DslPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case DslPackage.SMART_CITY_MODEL:
				sequence_SmartCityModel(context, (SmartCityModel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (name=ID stmts+=Statement+)
	 * </pre>
	 */
	protected void sequence_Action(ISerializationContext context, org.smartcitymodel.dsl.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns Actor
	 *     Actor returns Actor
	 *
	 * Constraint:
	 *     (name=ID properties+=Property* ports+=Port+ actions+=Action* location=Location)
	 * </pre>
	 */
	protected void sequence_Actor(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns CompoundEntity
	 *     CompoundEntity returns CompoundEntity
	 *
	 * Constraint:
	 *     (name=ID sensors+=Sensor* actors+=Actor*)
	 * </pre>
	 */
	protected void sequence_CompoundEntity(ISerializationContext context, CompoundEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (target=PortFQN | expr=PortFQN | expr=Expression)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ConditionalStatement
	 *     ConditionalStatement returns ConditionalStatement
	 *
	 * Constraint:
	 *     (condition=Condition effect=Effect)
	 * </pre>
	 */
	protected void sequence_ConditionalStatement(ISerializationContext context, ConditionalStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CONDITIONAL_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CONDITIONAL_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CONDITIONAL_STATEMENT__EFFECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CONDITIONAL_STATEMENT__EFFECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalStatementAccess().getConditionConditionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionalStatementAccess().getEffectEffectParserRuleCall_3_0(), semanticObject.getEffect());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connection returns Connection
	 *
	 * Constraint:
	 *     (name=ID sourceRef=PortFQN targetRef=PortFQN)
	 * </pre>
	 */
	protected void sequence_Connection(ISerializationContext context, Connection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CONNECTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CONNECTION__NAME));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CONNECTION__SOURCE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CONNECTION__SOURCE_REF));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CONNECTION__TARGET_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CONNECTION__TARGET_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConnectionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConnectionAccess().getSourceRefPortFQNParserRuleCall_3_0(), semanticObject.getSourceRef());
		feeder.accept(grammarAccess.getConnectionAccess().getTargetRefPortFQNParserRuleCall_5_0(), semanticObject.getTargetRef());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns Controller
	 *     Controller returns Controller
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         properties+=Property* 
	 *         ports+=Port+ 
	 *         actions+=Action* 
	 *         services+=Service* 
	 *         location=Location
	 *     )
	 * </pre>
	 */
	protected void sequence_Controller(ISerializationContext context, Controller semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Effect returns Effect
	 *
	 * Constraint:
	 *     (target=PortFQN | expr=Expression)
	 * </pre>
	 */
	protected void sequence_Effect(ISerializationContext context, Effect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Frequency returns Frequency
	 *
	 * Constraint:
	 *     (value=INT unit=TIME)
	 * </pre>
	 */
	protected void sequence_Frequency(ISerializationContext context, Frequency semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.FREQUENCY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.FREQUENCY__VALUE));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.FREQUENCY__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.FREQUENCY__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFrequencyAccess().getValueINTTerminalRuleCall_3_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getFrequencyAccess().getUnitTIMEEnumRuleCall_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Location returns Location
	 *
	 * Constraint:
	 *     (longitude=FLOAT latitude=FLOAT altitude=FLOAT)
	 * </pre>
	 */
	protected void sequence_Location(ISerializationContext context, Location semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.LOCATION__LONGITUDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.LOCATION__LONGITUDE));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.LOCATION__LATITUDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.LOCATION__LATITUDE));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.LOCATION__ALTITUDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.LOCATION__ALTITUDE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocationAccess().getLongitudeFLOATParserRuleCall_3_0(), semanticObject.getLongitude());
		feeder.accept(grammarAccess.getLocationAccess().getLatitudeFLOATParserRuleCall_6_0(), semanticObject.getLatitude());
		feeder.accept(grammarAccess.getLocationAccess().getAltitudeFLOATParserRuleCall_9_0(), semanticObject.getAltitude());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Port returns Port
	 *
	 * Constraint:
	 *     (id=INT direction=DIRECTION type=TYPE unit=UNIT)
	 * </pre>
	 */
	protected void sequence_Port(ISerializationContext context, Port semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PORT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PORT__ID));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PORT__DIRECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PORT__DIRECTION));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PORT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PORT__TYPE));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PORT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PORT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortAccess().getIdINTTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getPortAccess().getDirectionDIRECTIONEnumRuleCall_4_0(), semanticObject.getDirection());
		feeder.accept(grammarAccess.getPortAccess().getTypeTYPEEnumRuleCall_6_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPortAccess().getUnitUNITEnumRuleCall_8_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (name=ID type=TYPE access=ACCESS)
	 * </pre>
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PROPERTY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PROPERTY__NAME));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PROPERTY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PROPERTY__TYPE));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PROPERTY__ACCESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PROPERTY__ACCESS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropertyAccess().getTypeTYPEEnumRuleCall_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPropertyAccess().getAccessACCESSEnumRuleCall_4_0(), semanticObject.getAccess());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns Sensor
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (name=ID properties+=Property* ports+=Port+ frequency=Frequency? location=Location)
	 * </pre>
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.SERVICE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.SERVICE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getServiceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SmartCityModel returns SmartCityModel
	 *
	 * Constraint:
	 *     ((entities+=Entity+ connections+=Connection+) | connections+=Connection+)?
	 * </pre>
	 */
	protected void sequence_SmartCityModel(ISerializationContext context, SmartCityModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
